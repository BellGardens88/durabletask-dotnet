// ----------------------------------------------------------------------------------
// Copyright Microsoft Corporation
// Licensed under the Apache License, Version 2.0 (the "License").
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Threading;
using System.Threading.Tasks;
using DurableTask.Core;

namespace DurableTask;

public class TaskOrchestrationWrapper<TOutput> : TaskOrchestration
{
    readonly TaskName name;
    readonly Func<TaskOrchestrationContext, Task<TOutput?>> wrappedImplementation;
    readonly IWorkerContext workerContext;

    TaskOrchestrationContextWrapper? wrapperContext;

    public TaskOrchestrationWrapper(
        IWorkerContext workerContext,
        TaskName name,
        Func<TaskOrchestrationContext, Task<TOutput?>> wrappedImplementation)
    {
        this.workerContext = workerContext;
        this.name = name;
        this.wrappedImplementation = wrappedImplementation;
    }

    public override async Task<string?> Execute(OrchestrationContext innerContext, string rawInput)
    {
        this.wrapperContext = new(innerContext, this.name, rawInput, this.workerContext);

        // NOTE: If this throws, the error response will be generated by DurableTask.Core. However,
        //       it won't be consistent with our expected format. We currently work around this
        //       in the gRPC handling code, but ideally we wouldn't need this workaround.
        TOutput? output = await this.wrappedImplementation.Invoke(this.wrapperContext);

        // Return the output (if any) as a serialized string.
        return this.workerContext.DataConverter.Serialize(output);
    }

    public override string? GetStatus()
    {
        return this.wrapperContext?.GetDeserializedCustomStatus();
    }

    public override void RaiseEvent(OrchestrationContext context, string name, string input)
    {
        this.wrapperContext?.CompleteExternalEvent(name, input);
    }

    sealed class TaskOrchestrationContextWrapper : TaskOrchestrationContext
    {
        readonly Dictionary<string, IEventSource> externalEventSources = new(StringComparer.OrdinalIgnoreCase);
        readonly NamedQueue<string> externalEventBuffer = new();
        readonly Queue<Action> localActivityCalls = new();

        readonly OrchestrationContext innerContext;
        readonly TaskName name;
        readonly string rawInput;
        readonly IWorkerContext workerContext;

        object? customStatus;

        public TaskOrchestrationContextWrapper(
            OrchestrationContext innerContext,
            TaskName name,
            string rawInput,
            IWorkerContext workerContext)
        {
            this.innerContext = innerContext;
            this.name = name;
            this.rawInput = rawInput;
            this.workerContext = workerContext;
        }

        public override TaskName Name => this.name;

        public override string InstanceId => this.innerContext.OrchestrationInstance.InstanceId;

        public override bool IsReplaying => this.innerContext.IsReplaying;

        public override DateTime CurrentDateTimeUtc => this.innerContext.CurrentUtcDateTime;

        public override T GetInput<T>()
        {
            if (this.rawInput == null)
            {
                return default!;
            }

            return this.workerContext.DataConverter.Deserialize<T>(this.rawInput)!;
        }

        public override Task<T> CallActivityAsync<T>(
            TaskName name,
            object? input = null,
            TaskOptions? options = null)
        {
            // TODO: Retry options
            return this.innerContext.ScheduleTask<T>(name.Name, name.Version, input);
        }

        public override Task<T> CallActivityAsync<T>(Func<object?, T> activityLambda, object? input = null, TaskOptions? options = null)
        {
            if (options != null)
            {
                throw new NotImplementedException($"{nameof(TaskOptions)} are not yet supported.");
            }

            TaskCompletionSource<T> tcs = new();
            this.localActivityCalls.Enqueue(() =>
            {
                try
                {
                    T output = activityLambda(input);
                    tcs.SetResult(output);
                }
                catch (Exception ex)
                {
                    tcs.SetException(ex);
                }
            });

            return tcs.Task;
        }

        internal void ExecuteLocalActivityCalls()
        {
            while (this.localActivityCalls.Count > 0)
            {
                Action localActivityLambda = this.localActivityCalls.Dequeue();

                // Exceptions are never expected to escape here
                localActivityLambda.Invoke();
            }
        }

        public override Task<TResult> CallSubOrchestratorAsync<TResult>(
            TaskName orchestratorName,
            string? instanceId = null,
            object? input = null,
            TaskOptions? options = null)
        {
            if (options != null)
            {
                throw new NotImplementedException($"{nameof(TaskOptions)} are not yet supported.");
            }

            // TODO: Support for retry options and custom deserialization via TaskOptions
            return this.innerContext.CreateSubOrchestrationInstance<TResult>(
                orchestratorName.Name,
                orchestratorName.Version,
                instanceId ?? Guid.NewGuid().ToString("N"),
                input);
        }

        public override Task CreateTimer(DateTime fireAt, CancellationToken cancellationToken)
        {
            return this.innerContext.CreateTimer<object>(fireAt, state: null!, cancellationToken);
        }

        public override Task<T> WaitForExternalEvent<T>(string eventName, CancellationToken cancellationToken = default)
        {
            // Return immediately if this external event has already arrived.
            if (this.externalEventBuffer.TryTake(eventName, out string? bufferedEventPayload))
            {
                return Task.FromResult(this.workerContext.DataConverter.Deserialize<T>(bufferedEventPayload));
            }

            // Create a task completion source that will be set when the external event arrives.
            EventTaskCompletionSource<T> eventSource = new();
            if (this.externalEventSources.TryGetValue(eventName, out IEventSource? existing))
            {
                if (existing.EventType != typeof(T))
                {
                    throw new ArgumentException($"Events with the same name must have the same type argument. Expected {existing.EventType.FullName}.");
                }

                existing.Next = eventSource;
            }
            else
            {
                this.externalEventSources.Add(eventName, eventSource);
            }

            cancellationToken.Register(() => eventSource.TrySetCanceled(cancellationToken));
            return eventSource.Task;
        }

        public void CompleteExternalEvent(string eventName, string rawEventPayload)
        {
            if (this.externalEventSources.TryGetValue(eventName, out IEventSource? waiter))
            {
                object? value = this.workerContext.DataConverter.Deserialize(rawEventPayload, waiter.EventType);

                // Events are completed in FIFO order. Remove the key if the last event was delivered.
                if (waiter.Next == null)
                {
                    this.externalEventSources.Remove(eventName);
                }
                else
                {
                    this.externalEventSources[eventName] = waiter.Next;
                }

                waiter.TrySetResult(value);
            }
            else
            {
                // The orchestrator isn't waiting for this event (yet?). Save it in case
                // the orchestrator wants it later.
                this.externalEventBuffer.Add(eventName, rawEventPayload);
            }
        }

        public override void SetCustomStatus(object? customStatus)
        {
            this.customStatus = customStatus;
        }

        /// <inheritdoc/>
        public override void ContinueAsNew(object newInput, bool preserveUnprocessedEvents = true)
        {
            this.innerContext.ContinueAsNew(newInput);

            if (preserveUnprocessedEvents)
            {
                // Send all the buffered external events to ourself.
                OrchestrationInstance instance = new() { InstanceId = this.InstanceId };
                foreach ((string eventName, string eventPayload) in this.externalEventBuffer.TakeAll())
                {
                    this.innerContext.SendEvent(instance, eventName, eventPayload);
                }
            }
        }

        internal string? GetDeserializedCustomStatus()
        {
            return this.workerContext.DataConverter.Serialize(this.customStatus);
        }

        class EventTaskCompletionSource<T> : TaskCompletionSource<T>, IEventSource
        {
            /// <inheritdoc/>
            public Type EventType => typeof(T);

            /// <inheritdoc/>
            public IEventSource? Next { get; set; }

            /// <inheritdoc/>
            void IEventSource.TrySetResult(object result) => this.TrySetResult((T)result);
        }

        interface IEventSource
        {
            /// <summary>
            /// The type of the event stored in the completion source.
            /// </summary>
            Type EventType { get; }

            /// <summary>
            /// The next task completion source in the stack.
            /// </summary>
            IEventSource? Next { get; set; }

            /// <summary>
            /// Tries to set the result on tcs.
            /// </summary>
            /// <param name="result">The result.</param>
            void TrySetResult(object result);
        }

        class NamedQueue<TValue>
        {
            readonly Dictionary<string, Queue<TValue>> buffers = new(StringComparer.OrdinalIgnoreCase);

            public void Add(string name, TValue value)
            {
                if (!this.buffers.TryGetValue(name, out Queue<TValue>? queue))
                {
                    queue = new Queue<TValue>();
                    this.buffers[name] = queue;
                }

                queue.Enqueue(value);
            }

            public bool TryTake(string name, [NotNullWhen(true)] out TValue? value)
            {
                if (this.buffers.TryGetValue(name, out Queue<TValue>? queue))
                {
                    value = queue.Dequeue()!;
                    if (queue.Count == 0)
                    {
                        this.buffers.Remove(name);
                    }

                    return true;
                }

                value = default;
                return false;
            }

            public IEnumerable<(string eventName, TValue eventPayload)> TakeAll()
            {
                foreach ((string eventName, Queue<TValue> eventPayloads) in this.buffers)
                {
                    foreach (TValue payload in eventPayloads)
                    {
                        yield return (eventName, payload);
                    }
                }

                this.buffers.Clear();
            }
        }
    }
}
